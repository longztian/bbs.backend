<?php

namespace lzx\core;

class Cache
{
 // static class instead of singleton
    // here we don't use memory cache at all, becaue file cache is memory cache in Linux

    public static $status = false;
    public $path;
    private $logger;
    private $public_zone;
    private $private_zone;
    private $map_zone;

    private function __construct($path)
    {
        $this->path = $path;

        $this->public_zone = $path . '/public';
        $this->private_zone = $path . '/private';
        $this->map_zone = $path . '/map';

        if (!is_dir($this->public_zone)) {
            mkdir($this->public_zone, 0755, true);
        }
        if (!is_dir($this->private_zone)) {
            mkdir($this->private_zone, 0755, true);
        }
        if (!is_dir($this->map_zone)) {
            mkdir($this->map_zone, 0755, true);
        }
    }

    /*
     * @return \lzx\core\Cache
     */

    public static function getInstance($path = null)
    {
        static $instance;

        if (!isset($instance)) {
            if (is_null($path)) {
                throw new \Exception('error: no instance available. A cache path is required to create a new cache instance');
            }
            $instance = new self($path);
        }

        return $instance;
    }

    public function setLogger(Logger $logger)
    {
        $this->logger = $logger;
    }

    public function getStatus()
    {
        return self::$status;
    }

    public function setStatus($status)
    {
        self::$status = (bool) $status;
    }

    /*
     *  passing reference is only for paramater modification, will have low performance
     */

    public function store($key, $data, $public = false)
    {
        // never save content to cache file when MySQL has error
        if (!self::$status) {
            return;
        }

        if ($public) {
            // gzip data for public cache file used by webserver
            $data = gzencode($data, 6); // use 6 as default and equal to webserver gzip compression level
        }

        $fn = $this->getCacheFileName($key, $public);
        return $this->write($fn, $data);
    }

    /*
     * The function to fetch data returns false on failure
     */

    public function fetch($key)
    {
        // only fetch unzipped files from private zone
        if (!self::$status) {
            return false;
        }

        $fn = $this->getCacheFileName($key, false); // always fetch from private zone, webserver will use the public zone

        return $this->read($fn); // return FALSE on failure
    }

    /*
     * php only fetch page from private zone
     */

    public function fetchPage()
    {
        if ($_SERVER['REQUEST_METHOD'] === 'GET') {
            return $this->fetch($_SERVER['REQUEST_URI']);
        }

        return false;
    }

    /*
     * can store page in public zone or private zone
     */

    public function storePage($data, $public = true)
    {
// passing reference is only for paramater modification, will have low performance
        if ($_SERVER['REQUEST_METHOD'] === 'GET') {
            $this->store($_SERVER['REQUEST_URI'], $data, $public);
        }
    }

    public function delete($key)
    {
        // one small bug would be cocurency, child get deleted here but generated by another client process, while this content haven't get deleted yet.
        // so all maps and caches will break, after this node and map get deleted
        // FIRST: delete self
        $key = $this->cleanKey($key);
        if ($key[0] === '/') {
            // page cache, //robots don't have pages in private zone
            //$files = $this->public_zone . $key . '*.html.gz ' . $this->private_zone . $key . '*.html'; // include get parameters
            $files = glob($this->public_zone . $key . '*.html.gz');
            foreach ($files as $f) {
                $this->rm($f);
            }
            $files = glob($this->private_zone . $key . '*.html');
            foreach ($files as $f) {
                $this->rm($f);
            }
        } else {
            // fragment, only stored in private zone
            //$files = $this->private_zone . '/' . $key . '.txt';
            $file = $this->private_zone . '/' . $key . '.txt';
            $this->rm($file, false);
        }

        // get children cache
        $children = $this->fetchMap($key);

        // remove cache map
        $this->rm($this->getMapFileName($key, false), false);
        $this->rm($this->getMapFileName($key), false);

        // SECOND: recuservely delete child
        foreach ($children as $child) {
            $this->delete($child);
        }
    }

    public function storeMap($key, $childKey)
    {
        if (!self::$status) {
            return;
        }

        // save child map
        $children = $this->fetchRawMap($key);
        if (in_array($childKey, $children)) {
            $c_stored = true;
        } else {
            $fn_cmap = $this->getMapFileName($key);
            $c_stored = $this->write($fn_cmap, $childKey . PHP_EOL, true);
        }

        // save parent map
        $parents = $this->fetchRawMap($childKey, false);
        if (in_array($key, $parents)) {
            $p_stored = true;
        } else {
            $fn_pmap = $this->getMapFileName($childKey, false);
            $p_stored = $this->write($fn_pmap, $key . PHP_EOL, true);
        }

        return ( $c_stored && $p_stored );
    }

    public function fetchMap($key, $childMap = true)
    {
        $keys = [];
        // get all possible keys
        foreach ($this->fetchRawMap($key, $childMap) as $k) {
            // verify the key is in its children's parent list or its parents' child list
            if (in_array($key, $this->fetchRawMap($k, !$childMap))) {
                $keys[] = $k;
            }
        }
        return $keys;
    }

    private function fetchRawMap($key, $childMap = true)
    {
        $fn = $this->getMapFileName($key, $childMap);

        try {
            // read only if exist!!
            return is_file($fn) ? file($fn, \FILE_IGNORE_NEW_LINES | \FILE_SKIP_EMPTY_LINES) : [];
        } catch (\Exception $e) {
            $this->logger->warn('Could not read map [' . $fn . ']: ' . $e->getMessage());
            return [];
        }
    }

    public function clearAllCache()
    {
        $this->rm($this->map_zone);
        $this->rm($this->private_zone);
        $this->rm($this->public_zone);
        $this->logger->info('clear all cache');
    }

    private function rm($path, $reportError = true)
    {
        try {
            if (!is_dir($path)) {
                // remove file
                unlink($path);
            } else {
                // remove all children
                foreach (scandir($path) as $child) {
                    if ($child == '.' || $child == '..') {
                        continue;
                    }
                    $this->rm($path . '/' . $child);
                }

                // remove dir
                rmdir($path);
            }
        } catch (\Exception $e) {
            if ($reportError) {
                $this->logger->error($e->getMessage());
            }
        }
    }

    private function getMapFileName($key, $childMap = true)
    {
        static $fileNames = [];

        $cache_key = trim($key);
        if (strlen($cache_key) == 0 || strpos($cache_key, ' ') !== false) {
            throw new \Exception('invalid cache key : ' . $key);
        }

        if (!array_key_exists($cache_key, $fileNames)) {
            $key = $cache_key;

            // page uri or fragment file key
            $key = ($key[0] === '/' ? 'p_' : 'f_') . trim($key, '/');
            $key = preg_replace('/[^0-9a-z\.\_\-]/i', '_', $key);

            $fileName[$cache_key] = $this->map_zone . '/' . $key;
        }

        return $fileName[$cache_key] . ($childMap ? '.cmap' : '.pmap');
    }

    private function read($file)
    {
        try {
            // read only if exist!!
            return is_file($file) ? file_get_contents($file) : false;
        } catch (\Exception $e) {
            $this->logger->warn('Could not read from file [' . $file . ']: ' . $e->getMessage());
            return false;
        }
    }

    private function write($file, $data, $append = false)
    {
        $flag = $append ? (\FILE_APPEND | \LOCK_EX) : \LOCK_EX;
        try {
            return file_put_contents($file, $data, $flag) !== false;
        } catch (\Exception $e) {
            if (disk_free_space($this->path) < 10240) {
                $this->logger->info("no free space left");
                $this->clearAllCache();
            }
            $this->logger->warn('Could not write to file [' . $file . ']: ' . $e->getMessage());
            return false;
        }
    }

    private function getCacheFileName($key, $public = false)
    {
 // get private file name by default
        static $fileNames = [];
        $cache_key = ($public ? 'public_' : 'private_') . $key;

        if (!array_key_exists($cache_key, $fileNames)) {
            $key = $this->cleanKey($key);
            if ($key[0] === '/') {  // page
                if ($public) {  // output gz files, for webserver read
                    $fn = $this->public_zone . $key . '.html.gz';
                } else {  // use unzipped file, for php read and write
                    $fn = $this->private_zone . $key . '.html';
                }

                // create dir if not exist
                $dir = dirname($fn);
                if (!is_dir($dir)) {
                    mkdir($dir, 0755, true);
                }
            } else { // fragment only in private zone, so ignore $public
                if ($public) {
                    throw new \Exception('error: public zone can not have cache fragment');
                } else {
                    $fn = $this->private_zone . '/' . $key . '.txt';
                }
            }
            $fileName[$cache_key] = $fn;
        }

        return $fileName[$cache_key];
    }

    private function cleanKey($key)
    {
        static $keys = [];

        $key = trim($key);

        if (strlen($key) == 0 || strpos($key, ' ') !== false) {
            throw new \Exception('error cache key : ' . $key);
        }

        if (!array_key_exists($key, $keys)) {
            if ($key[0] === '/') {
                // page uri
                $keys[$key] = strpos($key, '?') ? str_replace('?', '#', $key) : ($key . '#');
            } else {
                // fragment or map key
                $keys[$key] = preg_replace('/[^0-9a-z\.\_\-]/i', '_', $key);
            }
        }

        return $keys[$key];
    }
}

//__END_OF_FILE__
